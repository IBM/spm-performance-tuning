"use strict";(self.webpackChunkcuram_performance_tuning=self.webpackChunkcuram_performance_tuning||[]).push([[205],{5557:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return s},default:function(){return h}});var a=t(45),r=(t(6540),t(5680)),o=t(4330);const i=["components"],s={},l={_frontmatter:s},p=o.A;function h(e){let{components:n}=e,t=(0,a.A)(e,i);return(0,r.yg)(p,Object.assign({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Use the tasks in the following section to monitor the system after you make the tuning changes."),(0,r.yg)("h2",null,"JVM"),(0,r.yg)("p",null,"To confirm and fine-tune the JVM heap size, turn on garbage collection (GC) logging by adding the following JVM parameter:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-shell"},"-verbose:gc\n")),(0,r.yg)("p",null,"On WebSphere® Application Server (WAS) with the IBM JVM, you can specify the location of the GC log file by setting the following JVM parameter:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-shell"},"-Xverbosegclog:<<path to file>>\n")),(0,r.yg)("p",null,"With a non-IBM JVM, you can specify the location by setting the following JVM parameter:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-shell"},"-Xloggc:<<path to file>>\n")),(0,r.yg)("p",null,"You can then process the GC log file to analyze the GC efficiency and identify better GC tuning values.\nAs a general convention, if more than 2% of the JVM time is spent doing garbage collection,\nadjust the heap size as described in the ",(0,r.yg)("a",{parentName:"p",href:"/curam-performance-tuning/tuneappserver/jvm-settings"},"JVM settings")," section."),(0,r.yg)("h2",null,"JVM heap size for WebSphere Application Server Liberty"),(0,r.yg)("p",null,"To get a heap dump if the JVM crashes, set the following JVM parameter:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-shell"},"-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$WLP_HOME/usr/servers/CuramServer/\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"-XX:+HeapDumpOnOutOfMemoryError")," generates a heap dump when an allocation from the Java™ heap or the permanent generation cannot be satisfied."),(0,r.yg)("h2",null,"Threads"),(0,r.yg)("p",null,"Monitor thread utilization in the thread pools. For example, the ",(0,r.yg)("inlineCode",{parentName:"p"},"WebSphere Performance Viewer - “Active Thread”"),"\ncounter shows the number of threads that are used in a thread pool. You can compare the counter with the defined\nnumber of threads to determine whether a thread pool is fully used."),(0,r.yg)("p",null,"If a thread pool shows as fully used and if spare CPU capacity exists, you can add a thread to the thread pool.\nThen, use the formulas that are described previously to update the connection pool sizes to reflect the new number of threads.\nIf no spare CPU capacity exists, then you must balance the tuning to favor either online or asynchronous processing."),(0,r.yg)("p",null,"Consider the case where the online thread pool is fully used, which results in poor user response times from the application server.\nYou might favor the online processing by decreasing the number of asynchronous threads by 1 and by increasing the number of online threads by 1."),(0,r.yg)("h2",null,"JDBC"),(0,r.yg)("p",null,"Monitor the prepared statement cache discards for the ",(0,r.yg)("inlineCode",{parentName:"p"},"jdbc/curamdb")," data source. For example,\nin WAS, monitor the ",(0,r.yg)("inlineCode",{parentName:"p"},"JDBC connection pools PrepStmtCacheDiscardCount")," in the ",(0,r.yg)("inlineCode",{parentName:"p"},"WebSphere Performance Viewer -Extended Statistic Set"),"."),(0,r.yg)("p",null,"Not reusing a prepared statement has a significant processing cost. Therefore, aim for no discards,\nand increase the prepared statement cache size if many discards are reported. If you are using the Oracle database,\nmonitor the maximum number of open cursors and update the configuration as needed."),(0,r.yg)("h2",null,"JMS"),(0,r.yg)("p",null,"Monitor the depth of JMS queues at run time. It indicates how many messages are waiting to be processed.\nFor example, in WAS the ",(0,r.yg)("inlineCode",{parentName:"p"},"AvailableMessageCount")," counter is available from the ",(0,r.yg)("inlineCode",{parentName:"p"},"WebSphere Performance Viewer-All Statistic-Queues-Queue Stat"),".\nThe following list indicates the key queues to monitor:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"DPEnactment")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"WorkflowEnactment")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"WorkflowActivity"))),(0,r.yg)("p",null,"If the rate of JMS message processing is not satisfactory and if spare CPU capacity exists,\nyou can increase the number of threads. Use either ",(0,r.yg)("inlineCode",{parentName:"p"},"SIBJMSRAThreadPool")," for WAS or ",(0,r.yg)("inlineCode",{parentName:"p"},"MDBWorkManager")," for WLS."),(0,r.yg)("p",null,"However, if no spare CPU capacity exists, review either the maximum concurrent endpoints for the queues in WAS or the beans\nin the free pool in WLS. In this case, either constrain the queues in WAS or the WLS free pool beans that have a\nlow depth to favor those queues with a high depth. That is, either the queues or the beans that have high queue depths or message counts need more resources."),(0,r.yg)("p",null,"For more information about applying the constraints, see ",(0,r.yg)("a",{parentName:"p",href:"/curam-performance-tuning/tuneappserver/jms-settings"},"WAS - activation specifications"),"\nor ",(0,r.yg)("a",{parentName:"p",href:"/curam-performance-tuning/tuneappserver/jms-settings"},"WLS - message driven beans"),"."))}h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-tuneappserver-monitoring-appserver-mdx-37a1586bcc096dbe810d.js.map