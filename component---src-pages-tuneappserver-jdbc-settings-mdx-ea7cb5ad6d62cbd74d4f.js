"use strict";(self.webpackChunkcuram_performance_tuning=self.webpackChunkcuram_performance_tuning||[]).push([[631],{3461:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return s},default:function(){return p}});var a=t(45),o=(t(6540),t(5680)),r=t(4330);const i=["components"],s={},c=(l="InlineNotification",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.yg)("div",e)});var l;const d={_frontmatter:s},u=r.A;function p(e){let{components:n}=e,t=(0,a.A)(e,i);return(0,o.yg)(u,Object.assign({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Set the JDBC connection pools for the Cúram data sources."),(0,o.yg)("h2",null,"Data source: jdbc/curamdb"),(0,o.yg)("p",null,"A Cúram transaction can require two JDBC connections, one for the transaction\nitself and another one for the key server. Size the",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamdb")," data source connection pool to prevent deadlocks,\nwith more connections available than threads that Cúram uses. Therefore, size the connection pool for the\n",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamdb")," data source by using the following formula:"),(0,o.yg)("br",null),(0,o.yg)("strong",null,"WebSphere"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"max_connections = WebContainer_max_threads + SIBJMSRAThreadPool_max_threads + 1\n")),(0,o.yg)("br",null),(0,o.yg)("strong",null,"WebLogic"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"max_connections = default_max_thread_constraint + MDBWorkManager_max_thread_constraint + 1\n")),(0,o.yg)("p",null,"If a firewall exists between the application servers and the database, to prevent issues that are\nrelated to ",(0,o.yg)("inlineCode",{parentName:"p"},"StaleConnectionException"),", we recommend setting ",(0,o.yg)("inlineCode",{parentName:"p"},"min_connections = 0")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"reapTime<= unused connection timeout <= firewall timeout"),"."),(0,o.yg)("p",null,"As a starting value for Cúram, set the data source prepared statement cache size for ",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamdb")," to ",(0,o.yg)("inlineCode",{parentName:"p"},"1000"),".\nThen, monitor the cache use and increase it if discards occur. In our experience, preventing discards can increase throughput by up to 20%."),(0,o.yg)(c,{mdxType:"InlineNotification"},(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Note:")," While we recommend an initial value of 1000 for the prepared statement cache to prevent discards,\nthis value can be too high for Cúram-based systems that have many threads and that are memory constrained.\nIn that case, it is recommended to review the SQLStats from the JMX Stats, from either load tests or production.\nThen, use a simple heuristic based on the distribution of SQL executions to find a smaller cache size that covers around\n90% of SQL executions from the application and gives a better balance between system performance and Java™ heap utilization.\nHowever, monitor prepared statement cache discards, system performance, and heap utilization, and adjust the cache size further as needed.")),(0,o.yg)("h2",null,"Data source: jdbc/curamsibdb"),(0,o.yg)("p",null,"As all Cúram transactions can potentially create a JMS message, size the connection pool for the ",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamsibdb")," data source by using the following formula:"),(0,o.yg)("br",null),(0,o.yg)("strong",null,"WebSphere"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"max_connections = WebContainer_max_threads + SIBJMSRAThreadPool_max_threads + 1\n")),(0,o.yg)("br",null),(0,o.yg)("strong",null,"WebLogic"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"max_connections = default_max_thread_constraint + MDBWorkManager_max_thread_constraint + 1\n")),(0,o.yg)("p",null,"To prevent the processing cost of pool growth and shrinkage, it is suggested to set",(0,o.yg)("inlineCode",{parentName:"p"},"min_connections = max_connections"),"."),(0,o.yg)("p",null,"If a firewall exists between the application servers and the database, to prevent issues that are related to ",(0,o.yg)("inlineCode",{parentName:"p"},"StaleConnectionException"),",\nwe recommend setting ",(0,o.yg)("inlineCode",{parentName:"p"},"min_connections = 0")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"reapTime<= unused connection timeout <= firewall timeout"),"."),(0,o.yg)("h2",null,"Data source: jdbc/curamtimerdb"),(0,o.yg)("p",null,"The EJB timer service is used by all Cúram transactions, but only once per transaction, in our application infrastructure\nand at the very start of an Cúram transaction. Currently, no reference to or usage of this service exists after the very start of an Cúram transaction."),(0,o.yg)("p",null,"You can tune the size of the ",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamtimerdb")," data source connection pool to be the same size as the number of threads,\nwhich would ensure that no contention can occur on the pool. However, given that the time that is spent using the\nEJB timer service is typically short compared to the duration of the transactions, a smaller size should work well\nwithout significant contention. So our advice is to start with the default size, monitor the system, and then increase\nthe size if evidence exists of a significant contention under normal conditions."),(0,o.yg)("p",null,"We have not had to resize the ",(0,o.yg)("inlineCode",{parentName:"p"},"jdbc/curamtimerdb")," data source connection pool in our load tests of Cúram in a default installation,\nwhere our application servers are tuned for high throughput and memory protection. In such an environment,\nthe number of threads is a low multiplier of the number of cores that are available to the application server,\nas documented in the ",(0,o.yg)("a",{parentName:"p",href:"/curam-performance-tuning/tuneappserver/thread-pools"},"Thread pools")," section."))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-tuneappserver-jdbc-settings-mdx-ea7cb5ad6d62cbd74d4f.js.map